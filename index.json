[{"content":"前言 Chocolatey是windows下的软件包管理工具，使用chocolatey可以快速的安装软件。\n安装 使用管理员权限模式打开powershell，粘贴下方安装代码，稍等片刻即可安装成功。\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)) 安装完成后输入choco -v 如何出现版本号即表示安装成功。\n使用 choco 常见命令 choco search \u0026lt;keyword\u0026gt; 搜索软件 choco list \u0026lt;keyword\u0026gt; 跟 search 命令功能类似 choco install \u0026lt;package1 package2 package3...\u0026gt; 安装软件 choco install \u0026lt;package\u0026gt; -version *** 安装指定版本 choco uninstall name 卸载软件 choco version \u0026lt;package\u0026gt; 查看安装包的版本情况 choco upgrade \u0026lt;package\u0026gt; 更新某个软件 choco list -localonly 查看一下所有安装在本地的包的列表 choco list -lo 功能同上 choco安装软件 choco官网可以查询可安装的软件包：https://community.chocolatey.org/packages\n常见软件：\n 7-zip : choco install 7zip.install git ：choco install git  go : choco install golang vscode: choco install vscode vim : choco install vim docker : choco install docker-cli docker-machine docker-compose docker-desktop docker-toolboxa  ","permalink":"https://shiluanzzz.github.io/post/20211208-2/","summary":"前言 Chocolatey是windows下的软件包管理工具，使用chocolatey可以快速的安装软件。\n安装 使用管理员权限模式打开powershell，粘贴下方安装代码，稍等片刻即可安装成功。\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)) 安装完成后输入choco -v 如何出现版本号即表示安装成功。\n使用 choco 常见命令 choco search \u0026lt;keyword\u0026gt; 搜索软件 choco list \u0026lt;keyword\u0026gt; 跟 search 命令功能类似 choco install \u0026lt;package1 package2 package3...\u0026gt; 安装软件 choco install \u0026lt;package\u0026gt; -version *** 安装指定版本 choco uninstall name 卸载软件 choco version \u0026lt;package\u0026gt; 查看安装包的版本情况 choco upgrade \u0026lt;package\u0026gt; 更新某个软件 choco list -localonly 查看一下所有安装在本地的包的列表 choco list -lo 功能同上 choco安装软件 choco官网可以查询可安装的软件包：https://community.chocolatey.org/packages\n常见软件：\n 7-zip : choco install 7zip.","title":"windows 安装Chocolatey"},{"content":"前言 之前在做一个计算机实训的时候，装docker环境报各种错误，今天尝试使用choco包管理工具，2行命令安装成功！\nchoco安装 Chocolatey是windows下的软件包管理工具，使用chocolatey可以快速的安装软件。\n使用管理员权限模式打开powershell，粘贴下方安装代码，稍等片刻即可安装成功。\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)) 安装完成后输入choco -v 如何出现版本号即表示安装成功。\ndocker 安装 在管理员cmd下输入如下命令\nchoco install docker-cli docker-machine docker-compose docker-desktop docker-toolbox 输入后会提示是否执行脚本，输入a回车，即可。\n测试安装情况 安装上述五个软件包后，需要自行启动docker-desktop软件，如果没有报错则安装成功。\n或者新开一个cmd窗口，输入命令docker-info, 如果没有保存则表示安装成功！\n常见报错  如果报如下图所示提示WSL 2 installation is incomplete ，是因为电脑没有安装linux子系统，   - 同样建议使用choco安装，输入命令choco install wsl2 安装后重试。\n","permalink":"https://shiluanzzz.github.io/post/20211208-1/","summary":"前言 之前在做一个计算机实训的时候，装docker环境报各种错误，今天尝试使用choco包管理工具，2行命令安装成功！\nchoco安装 Chocolatey是windows下的软件包管理工具，使用chocolatey可以快速的安装软件。\n使用管理员权限模式打开powershell，粘贴下方安装代码，稍等片刻即可安装成功。\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)) 安装完成后输入choco -v 如何出现版本号即表示安装成功。\ndocker 安装 在管理员cmd下输入如下命令\nchoco install docker-cli docker-machine docker-compose docker-desktop docker-toolbox 输入后会提示是否执行脚本，输入a回车，即可。\n测试安装情况 安装上述五个软件包后，需要自行启动docker-desktop软件，如果没有报错则安装成功。\n或者新开一个cmd窗口，输入命令docker-info, 如果没有保存则表示安装成功！\n常见报错  如果报如下图所示提示WSL 2 installation is incomplete ，是因为电脑没有安装linux子系统，   - 同样建议使用choco安装，输入命令choco install wsl2 安装后重试。","title":"windows下使用choco极速安装docker"},{"content":"Go 切片数据结构 Go 中常用的切片（Slice）数据结构是一枚动态数组，提供方便的局部索引功能，切片长度并不固定，并且会在容量不足时自动扩容。\n切片实质上是对一个底层数组的抽象视图 ，由 Go 运行时维护。在运行时，切片由如下的SliceHeader结构体表示，其中Data字段是指向底层数组的指针，Len表示当前切片的长度，而Cap表示当前切片的容量，也就是Data数组的大小。\ntype SliceHeader struct { Data uintptr Len int Cap int }  代码示例：Go 切片 Slice 数据结构\n 切片作为函数入参 许多 Go 开发者对传递切片作为函数入参的习惯性认知是：**传递切片，等同于传递指针，函数内部对切片的修改，将会影响到函数外部的切片。**这一习惯性认知在大部分情况下都是正确的。如以下代码所示：在modify函数中修改切片，外部main函数中的切片受到了影响。\npackage main import ( \u0026quot;fmt\u0026quot; ) func modify(s []string) { for i := 0; i \u0026lt; len(s); i++ { s[i] = \u0026quot;b\u0026quot; } fmt.Println(\u0026quot;Inner:\u0026quot;, s) } func main() { s := []string{\u0026quot;a1\u0026quot;, \u0026quot;a2\u0026quot;} fmt.Println(\u0026quot;Before:\u0026quot;, s) modify(s) fmt.Println(\u0026quot;After:\u0026quot;, s) }  代码示例：Go 切片作为函数入参\n Before: [a1 a2] Inner: [b b] After: [b b]  代码示例：Go 切片作为函数入参 - 程序输出\n 我们对示例代码做一些修改，在内部函数中触发切片的扩容机制 ，事情看起来就非常有趣了：函数内部对切片的修改并没有影响到函数外部的切片。\nfunc modify(s []string) { + s = append(s, \u0026quot;b\u0026quot;) for i := 0; i \u0026lt; len(s); i++ { s[i] = \u0026quot;b\u0026quot; } fmt.Println(\u0026quot;Inner:\u0026quot;, s) }  代码示例：Go 切片作为函数入参（切片扩容）\n Before: [a1 a2] Inner: [b b b] After: [a1 a2]  代码示例：Go 切片作为函数入参（切片扩容）- 程序输出\n 解释 在 Go 中，函数参数传递机制为值拷贝 。\n将切片作为函数参数传递，实际上是拷贝了SliceHeader结构体传入函数，结构体包含一枚指向底层数组的指针，因此在函数内修改切片，操作的底层数组是相同的。\n但是如果函数内的切片操作触发了切片扩容（如：使用append追加元素），Go 运行时会为切片分配一块新的内存空间并将原切片的所有元素拷贝过去，函数内部切片的底层数组指针指向了新分配 的内存空间，而函数外部切片底层数组指针仍指向分配前 的地址空间，由此出现了内外切片不一致的有趣情形。\n我们可以通过一个简单的方式验证扩容前后切片的变化：打印扩容前后切片数组的内存地址。在函数外部打印切片的数组地址，会发现其与切片扩容前地址相同。\nfunc modify(s []string) { + fmt.Printf(\u0026quot;Before grow slice, \u0026amp;s[0]: %p\\n\u0026quot;, \u0026amp;s[0]) s = append(s, \u0026quot;b\u0026quot;) for i := 0; i \u0026lt; len(s); i++ { s[i] = \u0026quot;b\u0026quot; } fmt.Println(\u0026quot;Inner:\u0026quot;, s) + fmt.Printf(\u0026quot;After grow slice, \u0026amp;s[0]: %p\\n\u0026quot;, \u0026amp;s[0]) }  代码示例：打印扩容前后切片数组地址（首元素地址）\n 建议 理解了 Go 中切片作为函数参数传递的内部原理后，如何在代码中正确运用切片传参也就比较明晰了。\n  操作不涉及切片容量变化，直接传递切片。\n  操作涉及切片容量变化，且需要反馈给调用方，传递切片指针。\n  参考资料   Arrays, slices (and strings): The mechanics of ‘append’：https://blog.golang.org/slices\n  Go 语言设计与实现：https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/\n  ","permalink":"https://shiluanzzz.github.io/post/go%E5%88%87%E7%89%87%E4%BC%A0%E5%85%A5%E9%A3%8E%E9%99%A9/","summary":"Go 切片数据结构 Go 中常用的切片（Slice）数据结构是一枚动态数组，提供方便的局部索引功能，切片长度并不固定，并且会在容量不足时自动扩容。\n切片实质上是对一个底层数组的抽象视图 ，由 Go 运行时维护。在运行时，切片由如下的SliceHeader结构体表示，其中Data字段是指向底层数组的指针，Len表示当前切片的长度，而Cap表示当前切片的容量，也就是Data数组的大小。\ntype SliceHeader struct { Data uintptr Len int Cap int }  代码示例：Go 切片 Slice 数据结构\n 切片作为函数入参 许多 Go 开发者对传递切片作为函数入参的习惯性认知是：**传递切片，等同于传递指针，函数内部对切片的修改，将会影响到函数外部的切片。**这一习惯性认知在大部分情况下都是正确的。如以下代码所示：在modify函数中修改切片，外部main函数中的切片受到了影响。\npackage main import ( \u0026quot;fmt\u0026quot; ) func modify(s []string) { for i := 0; i \u0026lt; len(s); i++ { s[i] = \u0026quot;b\u0026quot; } fmt.Println(\u0026quot;Inner:\u0026quot;, s) } func main() { s := []string{\u0026quot;a1\u0026quot;, \u0026quot;a2\u0026quot;} fmt.Println(\u0026quot;Before:\u0026quot;, s) modify(s) fmt.Println(\u0026quot;After:\u0026quot;, s) }  代码示例：Go 切片作为函数入参","title":"Go 传递切片入参的隐藏风险"},{"content":"因为实验室的PC和宿舍的笔记本数据无法互通，所以将Syncthing部署在服务器上备份同步代码文件等重要的小文件。\n下载部署在Linux服务器上  从官网下载Linux平台部署包   v1.18.2 备份\n syncthing-linux-amd64-v1.18.2.tar.gz\n 将文件复制到/usr/bin目录下   sudo cp syncthing /usr/bin/syncthing\n 先把服务跑一遍，让他自动生成配置文件   ./usr/bin/syncthing\n 服务默认是只能局域网访问，需要更改配置文件， 配置文件路径为/home/你的用户/.config/syncthing/config.xml   找到配置文件将address部分改成0.0.0.0/8384\n 放通8384端口 即可直接访问服务器的syncthing后台页面   记得设置密码！\n配置安装 windows平台安装 https://github.com/canton7/SyncTrayzor/releases\n在github下载图形界面安装包安装打开\n配置 默认只有127.0.0.1，localhost可以访问，没有远程访问权限。\n照下图，右边的设置，用来修改图形界面监听地址，并且可以设置随开机自动启动\n连接到服务器 添加后在云盘的管理界面接受即可\n添加需要同步的文件夹 点击添加文件夹 ，配置文件夹路径，根据自己的需求配置忽略模式 。 最后在共享里勾选共享到你的云盘\n在云盘中接受同步请求\n两个笔记本之间的数据同步 在另外一个笔记本中安装客户端，在服务器后台将对应的文件夹共享给你的设备即可。\n其实不需要服务器中转也可以，但是这要求你的两台电脑都在线而且速率会有限制。 利用服务器，备份+同步都达到了。\n","permalink":"https://shiluanzzz.github.io/post/syncthing/","summary":"因为实验室的PC和宿舍的笔记本数据无法互通，所以将Syncthing部署在服务器上备份同步代码文件等重要的小文件。\n下载部署在Linux服务器上  从官网下载Linux平台部署包   v1.18.2 备份\n syncthing-linux-amd64-v1.18.2.tar.gz\n 将文件复制到/usr/bin目录下   sudo cp syncthing /usr/bin/syncthing\n 先把服务跑一遍，让他自动生成配置文件   ./usr/bin/syncthing\n 服务默认是只能局域网访问，需要更改配置文件， 配置文件路径为/home/你的用户/.config/syncthing/config.xml   找到配置文件将address部分改成0.0.0.0/8384\n 放通8384端口 即可直接访问服务器的syncthing后台页面   记得设置密码！\n配置安装 windows平台安装 https://github.com/canton7/SyncTrayzor/releases\n在github下载图形界面安装包安装打开\n配置 默认只有127.0.0.1，localhost可以访问，没有远程访问权限。\n照下图，右边的设置，用来修改图形界面监听地址，并且可以设置随开机自动启动\n连接到服务器 添加后在云盘的管理界面接受即可\n添加需要同步的文件夹 点击添加文件夹 ，配置文件夹路径，根据自己的需求配置忽略模式 。 最后在共享里勾选共享到你的云盘\n在云盘中接受同步请求\n两个笔记本之间的数据同步 在另外一个笔记本中安装客户端，在服务器后台将对应的文件夹共享给你的设备即可。\n其实不需要服务器中转也可以，但是这要求你的两台电脑都在线而且速率会有限制。 利用服务器，备份+同步都达到了。","title":"Syncthing 数据网盘部署"},{"content":"参考链接 ： 知乎 博客\nRF框架参数意义    n_estimators:对原始数据集进行有放回抽样生成的子数据集个数，即决策树的个数。若n_estimators太小容易欠拟合，太大不能显著的提升模型，所以n_estimators选择适中的数值，版本0.20的默认值是10,版本0.22的默认值是100。\n  bootstrap:是否对样本集进行有放回抽样来构建树，True表示是,默认值True。\n  oob_score:是否采用袋外样本来评估模型的好坏\n   因为在有放回取样构建子模型的过程中，会有一部分数据没有取到，开启oob_score后可以使用这部分没有用到的数据在评估模型。\nRF决策树参数含义   max_features:构建决策树最优模型时考虑的最大特征数。   默认是\u0026quot;auto\u0026quot;，表示最大特征数是N的平方根;“log2\u0026quot;表示最大特征数是$log_{2}N$;\u0026ldquo;sqrt\u0026quot;表示最大特征数是$\\sqrt{N}$。\n max_depth:决策树最大深度。   若等于None,表示决策树在构建最优模型的时候不会限制子树的深度。如果模型样本量多，特征也多的情况下，推荐限制最大深度 ；若样本量少或者特征少，则不限制最大深度。\n min_samples_leaf:叶子节点含有的最少样本。   若叶子节点样本数小于min_samples_leaf，则对该叶子节点和兄弟叶子节点进行剪枝，只留下该叶子节点的父节点。整数型表示个数，浮点型表示取大于等于（样本数 * min_samples_leaf)的最小整数。min_samples_leaf默认值是1。\n min_samples_split:节点可分的最小样本数，   默认值是2。整数型和浮点型的含义与min_samples_leaf类似。\n max_leaf_nodes:最大叶子节点数。   int设置节点数,None表示对叶子节点数没有限制。\n min_impurity_decrease:节点划分的最小不纯度。   假设不纯度用信息增益表示，若某节点划分时的信息增益大于等于min_impurity_decrease，那么该节点还可以再划分；反之，则不能划分。\n criterion:表示节点的划分标准。   不纯度标准参考Gini指数，信息增益标准参考\u0026quot;entrop\u0026quot;熵。\n min_samples_leaf:叶子节点最小的样本权重和。   叶子节点如果小于这个值，则会和兄弟节点一起被剪枝，只保留叶子节点的父节点。默认是0，则不考虑样本权重问题。一般来说，如果有较多样本的缺失值或偏差很大，则尝试设置该参数值。\n随机生成最佳参数 随机生成最佳参数，使用RandomizedSearchCV() 从数据表格中随机抽取参数配置，对比选择最好的。缩小范围后在进行进一步调参。\nX,y=read_data() random_grid={ \u0026#39;n_estimators\u0026#39;: [i for i in range(10,1000,10)], \u0026#39;bootstrap\u0026#39;: [True,False], \u0026#39;max_depth\u0026#39;: [i for i in range(1,20,1)], \u0026#39;max_features\u0026#39;: [\u0026#39;auto\u0026#39;], \u0026#39;min_samples_leaf\u0026#39;: [i for i in range(1,30,1)], \u0026#39;min_samples_split\u0026#39;: [i for i in range(10,200,10)], } rf=RandomForestRegressor() rf_search=RandomizedSearchCV(estimator=rf, param_distributions=random_grid, n_iter=50, scoring=\u0026#39;neg_mean_absolute_error\u0026#39;, cv=3,verbose=2,random_state=233, n_jobs=-1 ) rf_search.fit(X,y) print(rf_search.best_params_) print(rf_search.best_estimator_) print(rf_search.best_score_) 随机森林调优实例 1.使用默认参数进行训练 from sklearn.ensemble import RandomForestClassifier rf_clf2=RandomForestClassifier( oob_score=True, random_state=666 ) rf_clf2.fit(X,y) rf_clf2.oob_score_ 可以看到使用默认参数的预测结果为0.89\n# 输出结果 RandomForestClassifier(bootstrap=True, class_weight=None, criterion=\u0026#39;gini\u0026#39;, max_depth=None, max_features=\u0026#39;auto\u0026#39;, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=10, n_jobs=None, oob_score=True, random_state=666, verbose=0, warm_start=False) 0.8926808073626417 2.对n_estimators参数择优 只对n_estimators进行调整，其他参数默认。n_estimators的择优范围是100-200，步长为2。(范围根据实际情况调整，因电脑性能较好，步长设置小)\ncv: 交叉验证参数，默认None，使用三折交叉验证。指定fold数量，默认为3。\nfrom sklearn.model_selection import GridSearchCV,cross_validate param_test1={\u0026#39;n_estimators\u0026#39;:range(100,220,2)} gsearch1=GridSearchCV( estimator=RandomForestClassifier(min_samples_split=100, min_samples_leaf=20, max_depth=10, random_state=10, max_features=\u0026#39;sqrt\u0026#39;, n_jobs=-1, ), param_grid=param_test1,scoring=\u0026#39;roc_auc\u0026#39;,cv=5 ) gsearch1.fit(X,y) 训练结束后，使用 best_params_和best_estimator_ 查看最优参数和最优模型参数。\n3.对max_depth，min_samples_split调参 在调节出 n_estimators 的最优参数后，对max_depth和min_samples_split参数进行调整。\n训练结束后网格搜索参数如右图。\n%%time param_test2={\u0026#39;max_depth\u0026#39;:range(10,30,1), \u0026#39;min_samples_split\u0026#39;:range(2,10,2)} gsearch2=GridSearchCV( estimator=RandomForestClassifier( n_estimators=164, min_samples_leaf=20, random_state=10, max_features=\u0026#39;sqrt\u0026#39;, oob_score=True, n_jobs=-1, ), param_grid=param_test2,scoring=\u0026#39;roc_auc\u0026#39;,cv=5,iid=False,) gsearch2.fit(X,y) 4.对min_samples_leaf 调参 继续对min_samples_leaf进行调参\n根据结果可以查看最优参数和最优评分，如右图\nparam_test3={\u0026#39;min_samples_leaf\u0026#39;:range(1,20,1)} gsearch3=GridSearchCV( estimator=RandomForestClassifier( n_estimators=165, max_depth=19, random_state=10, max_features=\u0026#39;sqrt\u0026#39;, oob_score=True, min_samples_split=2, n_jobs=-1, ), param_grid=param_test3,scoring=\u0026#39;roc_auc\u0026#39;,cv=5,iid=False,) gsearch3.fit(X,y) 5.max_features调参 param_test4={\u0026#39;max_features\u0026#39;:range(2,14,1)} gsearch4=GridSearchCV( estimator=RandomForestClassifier( n_estimators=165, max_depth=13, random_state=10, min_samples_leaf=3, min_samples_split=2, oob_score=True, n_jobs=-1, ), param_grid=param_test4,scoring=\u0026#39;roc_auc\u0026#39;,cv=5,iid=False, ) gsearch4.fit(X,y) 6 调参结束， from sklearn.ensemble import RandomForestClassifier random_forest_model=RandomForestClassifier( n_estimators=164, max_depth=13, random_state=10, min_samples_leaf=3, min_samples_split=2, oob_score=True, n_jobs=-1, max_features=6, ) random_forest_model.fit(X,y) random_forest_model.oob_score_ ","permalink":"https://shiluanzzz.github.io/post/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E8%B0%83%E5%8F%82/","summary":"参考链接 ： 知乎 博客\nRF框架参数意义    n_estimators:对原始数据集进行有放回抽样生成的子数据集个数，即决策树的个数。若n_estimators太小容易欠拟合，太大不能显著的提升模型，所以n_estimators选择适中的数值，版本0.20的默认值是10,版本0.22的默认值是100。\n  bootstrap:是否对样本集进行有放回抽样来构建树，True表示是,默认值True。\n  oob_score:是否采用袋外样本来评估模型的好坏\n   因为在有放回取样构建子模型的过程中，会有一部分数据没有取到，开启oob_score后可以使用这部分没有用到的数据在评估模型。\nRF决策树参数含义   max_features:构建决策树最优模型时考虑的最大特征数。   默认是\u0026quot;auto\u0026quot;，表示最大特征数是N的平方根;“log2\u0026quot;表示最大特征数是$log_{2}N$;\u0026ldquo;sqrt\u0026quot;表示最大特征数是$\\sqrt{N}$。\n max_depth:决策树最大深度。   若等于None,表示决策树在构建最优模型的时候不会限制子树的深度。如果模型样本量多，特征也多的情况下，推荐限制最大深度 ；若样本量少或者特征少，则不限制最大深度。\n min_samples_leaf:叶子节点含有的最少样本。   若叶子节点样本数小于min_samples_leaf，则对该叶子节点和兄弟叶子节点进行剪枝，只留下该叶子节点的父节点。整数型表示个数，浮点型表示取大于等于（样本数 * min_samples_leaf)的最小整数。min_samples_leaf默认值是1。\n min_samples_split:节点可分的最小样本数，   默认值是2。整数型和浮点型的含义与min_samples_leaf类似。\n max_leaf_nodes:最大叶子节点数。   int设置节点数,None表示对叶子节点数没有限制。\n min_impurity_decrease:节点划分的最小不纯度。   假设不纯度用信息增益表示，若某节点划分时的信息增益大于等于min_impurity_decrease，那么该节点还可以再划分；反之，则不能划分。\n criterion:表示节点的划分标准。   不纯度标准参考Gini指数，信息增益标准参考\u0026quot;entrop\u0026quot;熵。\n min_samples_leaf:叶子节点最小的样本权重和。   叶子节点如果小于这个值，则会和兄弟节点一起被剪枝，只保留叶子节点的父节点。默认是0，则不考虑样本权重问题。一般来说，如果有较多样本的缺失值或偏差很大，则尝试设置该参数值。\n随机生成最佳参数 随机生成最佳参数，使用RandomizedSearchCV() 从数据表格中随机抽取参数配置，对比选择最好的。缩小范围后在进行进一步调参。\nX,y=read_data() random_grid={ \u0026#39;n_estimators\u0026#39;: [i for i in range(10,1000,10)], \u0026#39;bootstrap\u0026#39;: [True,False], \u0026#39;max_depth\u0026#39;: [i for i in range(1,20,1)], \u0026#39;max_features\u0026#39;: [\u0026#39;auto\u0026#39;], \u0026#39;min_samples_leaf\u0026#39;: [i for i in range(1,30,1)], \u0026#39;min_samples_split\u0026#39;: [i for i in range(10,200,10)], } rf=RandomForestRegressor() rf_search=RandomizedSearchCV(estimator=rf, param_distributions=random_grid, n_iter=50, scoring=\u0026#39;neg_mean_absolute_error\u0026#39;, cv=3,verbose=2,random_state=233, n_jobs=-1 ) rf_search.","title":"随机森林调参"}]